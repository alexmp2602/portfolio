<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Parallax Scroll</title>
    <style>
      :root {
        --bg-dark: #1f1f1f;
        --fg: #fafafa;
        --accent: #60a98f;
      }
      * {
        box-sizing: border-box;
        margin: 0;
        user-select: none;
      }
      html,
      body {
        height: 100%;
      }
      body {
        font-family: ui-sans-serif, system-ui, sans-serif;
        color: var(--fg);
        background: var(--bg-dark);
        line-height: 1.45;
        overscroll-behavior: none;
      }
      .use-custom-cursor body {
        cursor: none;
      }

      .section {
        min-height: 100svh;
        display: grid;
        place-items: center;
        text-align: center;
        padding: 4rem 2rem;
        position: relative;
        overflow: hidden;
      }
      .title {
        font-size: clamp(1.6rem, 4vw, 2.6rem);
        font-weight: 800;
        letter-spacing: 0.01em;
        text-wrap: balance;
      }
      .muted {
        opacity: 0.75;
        font-weight: 600;
      }

      .bg-dark {
        background: var(--bg-dark);
      }
      .bg-accent {
        background: var(--accent);
        color: #111;
      }

      /* Parallax compatible iOS: fondo como capa con transform */
      .parallax {
        isolation: isolate;
        background: #0d0f10;
      }
      .parallax-bg {
        position: absolute;
        inset: -10% 0 -10% 0;
        z-index: -1;
        background-image: url("https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=crop&w=1600&q=80");
        background-size: cover;
        background-position: center;
        transform: translateY(var(--bgOffset, 0px));
        filter: contrast(1.05) brightness(0.9);
        will-change: transform; /* se quita al salir de vista */
      }

      .layer {
        transform: translateY(var(--offset, 0px));
        transition: transform 0.18s cubic-bezier(0.17, 0.84, 0.44, 1);
        text-align: center;
      }

      /* Reveal sutil al entrar */
      .reveal {
        opacity: 0;
        transform: translateY(16px);
      }
      .reveal.is-in {
        opacity: 1;
        transform: translateY(0);
        transition: opacity 0.5s ease, transform 0.5s ease;
      }

      /* Cursor minimal (solo desktop sin reduce-motion) */
      .cursor {
        position: fixed;
        left: 0;
        top: 0;
        width: 22px;
        height: 22px;
        border-radius: 999px;
        border: 2px solid var(--accent);
        transform: translate(-50%, -50%);
        pointer-events: none;
        z-index: 9999;
        mix-blend-mode: difference;
        opacity: 0.9;
      }
      .no-custom-cursor .cursor {
        display: none;
      }
    </style>
  </head>
  <body>
    <section class="section bg-dark">
      <div class="layer reveal" data-speed="0.25">
        <h1 class="title">Parallax Scroll Demo</h1>
        <p class="muted">Capas sutiles moviéndose al deslizar hacia abajo</p>
      </div>
    </section>

    <section class="section parallax">
      <div class="parallax-bg"></div>
      <div class="layer reveal" data-speed="0.18">
        <h2 class="title">Fondo con parallax</h2>
        <p class="muted">
          Compatibilidad total (sin <code>background-attachment</code>)
        </p>
      </div>
    </section>

    <section class="section bg-accent">
      <div class="layer reveal" data-speed="0.32">
        <h2 class="title">Contenido</h2>
        <p class="muted">Movimiento suave y performante</p>
      </div>
    </section>

    <div class="cursor"></div>

    <script>
      (function () {
        const isTouch =
          "ontouchstart" in window || navigator.maxTouchPoints > 0;
        const reduce = matchMedia("(prefers-reduced-motion: reduce)").matches;
        document.documentElement.classList.add(
          isTouch || reduce ? "no-custom-cursor" : "use-custom-cursor"
        );

        const layers = Array.from(document.querySelectorAll(".layer"));
        const parallaxBg = document.querySelector(".parallax-bg");

        // Solo animamos elementos visibles
        const visible = new Set();
        const io = new IntersectionObserver(
          (entries) => {
            for (const e of entries) {
              if (e.isIntersecting) {
                visible.add(e.target);
                e.target.classList.add("is-in"); // reveal
                // activar will-change solo cuando entra
                if (e.target === parallaxBg)
                  parallaxBg.style.willChange = "transform";
              } else {
                visible.delete(e.target);
                if (e.target === parallaxBg) parallaxBg.style.willChange = "";
              }
            }
          },
          { rootMargin: "10% 0% 10% 0%" }
        );

        // Marcar reveal targets
        document.querySelectorAll(".reveal").forEach((el) => io.observe(el));
        if (parallaxBg) io.observe(parallaxBg);

        // Utilidades
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const lerp = (a, b, t) => a + (b - a) * t;

        let targetY = window.scrollY,
          currentY = targetY;
        let ticking = false;

        function update() {
          // Lerp para suavizar
          currentY = lerp(currentY, targetY, 0.12);

          // Para cada layer visible, calcular offset relativo a su sección
          const vh = window.innerHeight;
          visible.forEach((el) => {
            if (!el.classList.contains("layer")) return;
            const rect = el.getBoundingClientRect();
            // distancia del centro del viewport al centro del elemento
            const delta = vh / 2 - (rect.top + rect.height / 2);
            const speed = parseFloat(el.dataset.speed || "0.25");
            const offset = clamp(delta * speed, -200, 200); // límites para no exagerar
            el.style.setProperty("--offset", offset.toFixed(2) + "px");
          });

          // Fondo parallax (más sutil)
          if (parallaxBg && visible.has(parallaxBg)) {
            const sRect = parallaxBg.parentElement.getBoundingClientRect();
            const rel = vh / 2 - (sRect.top + sRect.height / 2);
            const bgOffset = clamp(rel * 0.1, -120, 120);
            parallaxBg.style.setProperty(
              "--bgOffset",
              bgOffset.toFixed(2) + "px"
            );
          }

          if (Math.abs(targetY - currentY) > 0.1) {
            requestAnimationFrame(update);
          } else {
            ticking = false;
          }
        }

        function onScroll() {
          targetY = window.scrollY || window.pageYOffset;
          if (!ticking && !reduce) {
            ticking = true;
            requestAnimationFrame(update);
          }
        }

        // Primera pintada
        onScroll();
        addEventListener("scroll", onScroll, { passive: true });
        addEventListener("resize", onScroll);

        // Cursor (solo si procede)
        if (!isTouch && !reduce) {
          const cursor = document.querySelector(".cursor");
          let cx = innerWidth / 2,
            cy = innerHeight / 2,
            rafId = 0;
          function move(e) {
            cx = e.clientX;
            cy = e.clientY;
            if (!rafId) {
              rafId = requestAnimationFrame(() => {
                cursor.style.transform = `translate(${cx}px, ${cy}px)`;
                rafId = 0;
              });
            }
          }
          addEventListener("mousemove", move, { passive: true });
        }
      })();
    </script>
  </body>
</html>
